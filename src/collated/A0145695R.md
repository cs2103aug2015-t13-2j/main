# A0145695R
###### command\Command.java
``` java

public class Command implements java.io.Serializable{
	private String commandName;
	private String directory;
	private int taskNumber;
	private Task task;
	private EditSpecification editSpecification;
	private String searchSpecification;
	private String errorMessage;
	private String sortField;
	protected Storage storage;
	

	public Command() {
		commandName = "";
		directory = "";
		taskNumber = -1;
		directory = "";
		task = null;
		editSpecification = null;
		searchSpecification = "";
		errorMessage = "";
		sortField = "";
		storage = storage.getInstance();
	}
	
	public String execute(){
		String msg = "";
		return msg;
	}
	
	public String undo(){
		String msg = "";
		return msg;
	}
	
	
	public void setDirectory(String directory){
		this.directory = directory;
	}
	
	
	public String getDirectory(){
		return directory;
	}
	
	public String getCommandName() {
		return commandName;
	}

	public void setCommandName(String commandName) {
		this.commandName = commandName;
	}

	public int getTaskNumber() {
		return taskNumber;
	}
	
	public void setTaskNumber(int taskNumber) {
		this.taskNumber = taskNumber;
	}

	public Task getTask() {
		return task;
	}

	public void setTask(Task task) {
		this.task = task;
	}

	public EditSpecification getEditSpecification() {
		return editSpecification;
	}

	public void setEditSpecification(EditSpecification editSpecification) {
		this.editSpecification = editSpecification;
	}
	
	
	public String getErrorMessage() {
		return errorMessage;
	}
	

	public void setErrorMessage(String errorMessage) {
		this.errorMessage = errorMessage;
	}

	public String getSearchSpecification() {
		return searchSpecification;
	}

	public void setSearchSpecification(String searchSpecification) {
		this.searchSpecification = searchSpecification;
	}

	public String getSortField() {
		return sortField;
	}

	public void setSortField(String sortField) {
		this.sortField = sortField;
	}

	
}
```
###### command\Edit.java
``` java

import org.joda.time.DateTime;

import parser.*;


```
###### NexTask\DateSorter.java
``` java

import java.util.Comparator;

import org.joda.time.DateTime;

/**
 * DateSorter sorts from earliest go latest.
 *
 */
public class DateSorter implements Comparator<Task>{
	
	public int compare(Task t1, Task t2) {
		if ((t1.getTaskType().equals("todo")) && (t2.getTaskType().equals("todo"))){
			return 0;
		} else if(t1.getTaskType().equals("todo")) {
			return 1;
		} else if(t2.getTaskType().equals("todo")) {
			return -1;
		} else {
			DateTime d1 = getTaskDate(t1);
			DateTime d2 = getTaskDate(t2);
			return d1.compareTo(d2);
		}
	}

	private DateTime getTaskDate(Task t) {
		assert(!(t.getTaskType().equals("todo")));
		if(t.getTaskType().equals("event")) {
			return t.getStart();
		} else {
			return t.getCompleteBy();
		} 
	}
		
}
```
###### NexTask\EditSpecification.java
``` java
public class EditSpecification implements java.io.Serializable {
	private int taskNumber;
	private String fieldToEdit;
	private String theEdit;
	private String fieldToClear;

	public EditSpecification() {
		taskNumber = -1;
		fieldToEdit = "";
		theEdit = "";
		fieldToClear = "";
	}

	public EditSpecification(int taskNum, String field, String edit) {
		this.taskNumber = taskNum;
		this.fieldToEdit = field;
		this.theEdit = edit;
	}

	public int getTaskNumber() {
		return taskNumber;
	}

	public void setTaskNumber(int taskNumber) {
		this.taskNumber = taskNumber;
	}

	public String getFieldToEdit() {
		return fieldToEdit;
	}

	public void setFieldToEdit(String fieldToEdit) {
		this.fieldToEdit = fieldToEdit;
	}

	public String getTheEdit() {
		return theEdit;
	}

	public void setTheEdit(String theEdit) {
		this.theEdit = theEdit;
	}

	public String getFieldToClear() {
		return fieldToClear;
	}

	public void setFieldToClear(String fieldToClear) {
		this.fieldToClear = fieldToClear;
	}

	public boolean equals(EditSpecification other) {
		if (this.getTaskNumber() == other.getTaskNumber() && this.getFieldToEdit().equals(other.getFieldToEdit())
				&& this.getTheEdit().equals(other.getTheEdit())) {
			return true;
		} else {
			return false;
		}
	}

	public String toString() {
		return "Edit Specs \n Task Number: " + this.getTaskNumber() + "\n Field To Edit: " + this.getFieldToEdit()
				+ "\n The Edit: " + this.getTheEdit() + "\n Field To Clear: " + this.getFieldToClear();
	}

}
```
###### NexTask\Logic.java
``` java
public class Logic implements Observer {
	private static final String CMD_EDIT = "edit";
	private static final String CMD_ADD = "add";
	private static final String CMD_VIEW_INCOMPLETE= "view incomplete";
	private static final String CMD_DELETE = "delete";
	private static final String CMD_STORE = "store";
	private static final String CMD_EXIT = "exit";
	private static final String CMD_UNDO = "undo";
	private static final String CMD_COMPLETE = "complete";
	private static final String CMD_HELP = "help";
	private static final String CMD_SORT = "sort";
	private static final String CMD_VIEW_COMPLETED = "view completed";
	private static final String CMD_SEARCH = "search";
	private static final String CMD_RETRIEVE = "retrieve";
	private static final String CMD_INVALID = "invalid";
	private static final String FILE_TO_RETREIVE = "ForRetrieval.txt";
	private static final String LOG_PROCESS = "going to start processing";
	private static final String LOG_END = "end of processing";
	private static final String LOG_ERROR = "processing error";
	private static final String LOG_FILE_NAME = "LogicLogFile.log";
	private static final String LOG_ERROR_INITIALIZE = "Cannot intialize log file!";	
	private static final String COMMAND_HELP = "The following commands are as shown:\n"
			+ "To add an event: add event start (date & time) end (date & time) (description of task).\n"
			+ "To add a task with deadline: add deadline due by (date & time) (description of task).\n"
			+ "To add a task with no deadline: add todo (description of task).\n"
			+ "To add a recurring task: add repeat (description of task).\n"
			+ "To mark a task as completed: finished/completed (task number).\n"
			+ "To delete a task: delete (task number).\n"
			+ "To edit a specific task: edit (task number) (name/date/start/end) (the edit).\n"
			+ "To undo a certain task: undo"
			+ "To search: search (field you want to search) (description of search term).\n"
			+ "To retrieve an archive of completed tasks: archive.\n"
			+ "To display the current list of tasks: display.\n" 
			+ "To save to: save to (filename).";
	
	private static final String INVALID_COMMAND = "There is no such command available for usage.";
	private static final String SUCCESSFUL_SORT = "Tasks has been sorted";
	private static final String SUCCESSFUL_EDIT = "Task has been edited!";

	private static Logger logger = Logger.getLogger("Logic");
	private static FileHandler fh;
	private static SimpleFormatter formatter;
	private Storage storage;
	private CommandParser parser;
	private boolean hasUpdate;

	public Logic() {
		storage = Storage.getInstance();
		parser = new CommandParser();
		parser.initializeLogger();
		hasUpdate = false;
		try {
			this.fh = new FileHandler(LOG_FILE_NAME, true);
		} catch (SecurityException | IOException e) {
			System.out.println(LOG_ERROR_INITIALIZE);
			System.exit(1);
		}
		this.logger.addHandler(fh);
		formatter = new SimpleFormatter();  
        this.fh.setFormatter(formatter);

	}
	public Logic(boolean clear) {
		storage = Storage.getInstance();
		parser = new CommandParser();
		parser.initializeLogger();
		hasUpdate = false;
		try {
			this.fh = new FileHandler(LOG_FILE_NAME, true);
		} catch (SecurityException | IOException e) {
			System.out.println(LOG_ERROR_INITIALIZE);
			System.exit(1);
		}
		this.logger.addHandler(fh);
		formatter = new SimpleFormatter();  
        this.fh.setFormatter(formatter);
        if(clear == true) {
        	this.getTaskList().clear();
        }

	}
	/**
	 * Takes user input and determines if valid. If it is valid, will perform,
	 * otherwise return error message.
	 * 
	 * @param userInput
	 * @return either a message specifying the result of executing command or an
	 *         error message.
	 */
	public String executeUserCommand(String userInput) {
		logger.log(Level.INFO, LOG_PROCESS);
		Command cmd = getUserCommand(userInput);
		String printMsg = "";
		if (isValid(cmd)) {
			printMsg = performCommand(cmd, storage);
		} else {
			printMsg = cmd.getErrorMessage();
		}
		logger.log(Level.INFO, LOG_END);
		return printMsg;
	}

	public boolean isValid(Command command) {
		if (command.getCommandName() != CMD_INVALID) {
			return true;
		} else {
			return false;
		}
	}

	public Command getUserCommand(String userInput) {
		return parser.parse(userInput);
	}

	private String performCommand(Command cmd, Storage taskList) {
		logger.log(Level.INFO, LOG_PROCESS);
		String messageToPrint = cmd.execute();
		try {
			storage.storeToDefault();
		} catch (FileNotFoundException e) {
			System.out.println(String.format(FILE_TO_RETREIVE));
			logger.log(Level.WARNING, LOG_ERROR, e);
		}
		logger.log(Level.INFO, LOG_END);
		return messageToPrint;
	}

	public Storage getStorage() {
		return storage;
	}
	
	public ArrayList<Task> getTaskList(){
		return storage.getTaskArray();
	}
	
	public ArrayList<Task> getCompletedTaskList() {
		return storage.getCompletedTasks();
	}
	
	@Override
	public void update() {
		hasUpdate = true;	
	}
	
	public boolean getHasUpdate() {
		return hasUpdate;
	}
	
	public void resetHasUpdate() {
		hasUpdate = false;
	} 

}
```
###### NexTask\NameSorter.java
``` java

import java.util.Comparator;

/**
 * NameSorter sorts tasks in alphabetical order.
 *
 */
public class NameSorter implements Comparator<Task>{
	public int compare(Task t1, Task t2) {
		return t1.getName().compareTo(t2.getName());
	}
}
```
###### NexTask\Observable.java
``` java

public interface Observable {
	public void addObserver(Observer o);
	public void notifyObservers();	
}
```
###### NexTask\Observer.java
``` java

public interface Observer {
	public void update();
}
```
###### parser\CommandParser.java
``` java

/**
 * CommandParser parses user input and create Command objects with appropriate
 * fields initialized.
 *
 */
public class CommandParser implements java.io.Serializable {
	// Indices
	private static final int POSITION_OF_CMD = 0;
	private static final int POSITION_OF_CMD_ARGS = 1;

	// Size
	private static final String EMPTY_STRING = "";

	// Command types
	private static final String USER_COMMAND_ADD = "add";
	private static final String USER_COMMAND_DELETE = "delete";
	private static final String USER_COMMAND_VIEW_INCOMPLETE = "view incomplete";
	private static final String USER_COMMAND_EDIT = "edit";
	private static final String USER_COMMAND_EXIT = "exit";
	private static final String USER_COMMAND_STORE = "store";
	private static final String USER_COMMAND_SEARCH = "search";
	private static final String USER_COMMAND_COMPLETE = "complete";
	private static final String USER_COMMAND_UNDO = "undo";
	private static final String USER_COMMAND_SORT = "sort";
	private static final String USER_COMMAND_VIEW_COMPLETED = "view completed";
	private static final String USER_COMMAND_RETRIEVE = "retrieve";
	private static final String INVALID = "invalid";

	// Task types
	private static final String TASK_TYPE_EVENT = "event";
	private static final String TASK_TYPE_DEADLINE = "deadline";
	private static final String TASK_TYPE_TODO = "todo";

	// Keywords
	private static final String KW_START = "start";
	private static final String KW_END = "end";
	private static final String KW_ON = "on";
	private static final String KW_BY = "by";
	private static final String KW_CLEAR = "clear";

	// Patterns
	private static final String PATTERN_DATE = "\"([^\"]*)\"";
	private static final String PATTERN_TASK_NAME = "([\\w\\s]+)";

	// Error Messages
	private static final String ERROR_INVALID_CMD = "Please enter a valid command.";
	private static final String ERROR_NO_NAME_FOUND = "Pleae provide a name for your task.";
	private static final String ERROR_INVALID_DATE_FORMAT = "Invalid date. Make sure your date is valid and enter \"help\" if you need to see accepted date formats.";
	private static final String ERROR_INTEGER_NOT_FOUND = "Please specify task number as an integer.";
	private static final String ERROR_INVALID_NUM_ARGS = "Invalid number of arguments. Enter \"help\" to view command format.";
	private static final String ERROR_NO_TASK_NUM = "Please provide a task number.";
	private static final String ERROR_NO_SORT_FIELD = "Please specify field you wish to sort by.";
	private static final String ERROR_NO_SEARCH_FIELD = "Please specify what you would like to search for.";

	// Log Messages
	private static final String LOG_MSG_INVALID_CMD = "Command Parser: Please enter a valid command.";
	private static final String LOG_MSG_INVALID_DATE_FMT = "Command Parser: Error parsing date.";
	private static final String LOG_MSG_NO_NAME_FOUND = "Command Parser: User did not provide task name.";
	private static final String LOG_PROCESS = "going to start processing";
	private static final String LOG_END = "end of processing";
	private static final String LOG_END_1 = "end of processong parser add";
	private static final String LOG_END_2 = "end of processong parser edit";
	private static final String LOG_END_3 = "end of processong parser delete";
	private static final String LOG_END_4 = "end of processong parser complete";
	private static final String LOG_END_5 = "end of processong parser search";
	private static final String LOG_END_6 = "end of processong parser sort";
	private static final String LOG_END_7 = "end of processong parser store";
	private static final String LOG_END_8 = "end of processong parser view completed";
	private static final String LOG_END_9 = "end of processong parser view incomplete";
	private static final String LOG_END_10 = "end of processong parser undo";
	private static final String LOG_END_11 = "end of processong parser exit";
	private static final String LOG_END_12 = "end of processong parser retrieve";
	private static final String LOG_END_13 = "end of processong parser invalid";
	private static final String LOG_ERROR = "processing error";
	private static final String LOG_FILE_NAME = "CommandParserLogFile.log";
	private static final String LOG_ERROR_INITIALIZE = "Cannot intialize log file!";
	private static Logger logger = Logger.getLogger("CommandParser");
	private static FileHandler fh;
	private static SimpleFormatter formatter;

	public void initializeLogger() {
		try {
			this.fh = new FileHandler(LOG_FILE_NAME);
		} catch (SecurityException | IOException e) {
			System.out.println(LOG_ERROR_INITIALIZE);
			System.exit(1);
		}
		this.logger.addHandler(fh);
		formatter = new SimpleFormatter();
		this.fh.setFormatter(formatter);
	}

	public Command parse(String userInput) {
		logger.log(Level.INFO, LOG_PROCESS);
		String userCommand;
		// check if user input empty
		String commandArgs;

		if (userInput.equals(USER_COMMAND_VIEW_COMPLETED)) {
			userCommand = USER_COMMAND_VIEW_COMPLETED;
			commandArgs = EMPTY_STRING;
		} else if (userInput.equals(USER_COMMAND_VIEW_INCOMPLETE)) {
			userCommand = USER_COMMAND_VIEW_INCOMPLETE;
			commandArgs = EMPTY_STRING;
		} else {
			String[] input = userInput.split(" ", 2);
			if (input.length > 1) {
				userCommand = getCommand(input);
				commandArgs = getCommandArgs(input);
			} else {
				userCommand = userInput.trim();
				commandArgs = EMPTY_STRING;
			}
		}

		switch (userCommand.toLowerCase().trim()) {
		case USER_COMMAND_ADD:
			logger.log(Level.INFO, LOG_END_1);
			return initAddCommand(commandArgs);
		case USER_COMMAND_EDIT:
			logger.log(Level.INFO, LOG_END_2);
			return initEditCommand(commandArgs);
		case USER_COMMAND_DELETE:
			logger.log(Level.INFO, LOG_END_3);
			return initDeleteCommand(commandArgs);
		case USER_COMMAND_COMPLETE:
			logger.log(Level.INFO, LOG_END_4);
			return initCompleteCommand(commandArgs);
		case USER_COMMAND_SEARCH:
			logger.log(Level.INFO, LOG_END_5);
			return initSearchCommand(commandArgs);
		case USER_COMMAND_SORT:
			logger.log(Level.INFO, LOG_END_6);
			return initSortCommand(commandArgs);
		case USER_COMMAND_STORE:
			logger.log(Level.INFO, LOG_END_7);
			return initStoreCommand(commandArgs);
		case USER_COMMAND_VIEW_COMPLETED:
			logger.log(Level.INFO, LOG_END_8);
			return initViewCompletedCommand(USER_COMMAND_VIEW_COMPLETED);
		case USER_COMMAND_VIEW_INCOMPLETE:
			logger.log(Level.INFO, LOG_END_9);
			return initViewIncompleteCommand(USER_COMMAND_VIEW_INCOMPLETE);
		/*
		 * case USER_COMMAND_HELP: return initHelpCommand(USER_COMMAND_HELP);
		 */
		case USER_COMMAND_UNDO:
			logger.log(Level.INFO, LOG_END_10);
			return initUndoCommand(USER_COMMAND_UNDO);
		case USER_COMMAND_EXIT:
			logger.log(Level.INFO, LOG_END_11);
			return initCommand(USER_COMMAND_EXIT);
		case USER_COMMAND_RETRIEVE:
			logger.log(Level.INFO, LOG_END_12);
			return initRetrieveCommand(USER_COMMAND_RETRIEVE);
		default:
			logger.log(Level.INFO, LOG_END_13);
			return initInvalidCommand(ERROR_INVALID_CMD);
		}
	}

	public String getCommand(String[] input) {
		return input[POSITION_OF_CMD];
	}

	public String getCommandArgs(String[] input) {
		return input[POSITION_OF_CMD_ARGS];
	}

	/**
	 * @param commandArgs
	 *            details regarding the task the user wants to add
	 * @return This method will return an add command if the user input is in
	 *         correct format, otherwise it will return an invalid command with
	 *         error message initialized accordingly.
	 */
	private Command initAddCommand(String commandArgs) {
		logger.log(Level.INFO, LOG_PROCESS);
		Add cmd = new Add();
		if (isEvent(commandArgs.toLowerCase().trim())) {
			Task newEvent = parseEvent(commandArgs);
			if (newEvent.getName().equals(INVALID)) {
				logger.log(Level.INFO, LOG_END);
				return initInvalidCommand(ERROR_INVALID_DATE_FORMAT);
			} else if (newEvent.getName().equals(EMPTY_STRING)) {
				logger.log(Level.INFO, LOG_END);
				return initInvalidCommand(ERROR_NO_NAME_FOUND);
			} else {
				cmd.setCommandName(USER_COMMAND_ADD);
				cmd.setTask(newEvent);
			}
		} else if (isDeadline(commandArgs.toLowerCase().trim())) {
			Task newDeadline = parseDeadline(commandArgs);
			if (newDeadline.getName().equals(INVALID)) {
				logger.log(Level.INFO, LOG_END);
				return initInvalidCommand(ERROR_INVALID_DATE_FORMAT);
			} else if (newDeadline.getName().equals(EMPTY_STRING)) {
				logger.log(Level.INFO, LOG_END);
				return initInvalidCommand(ERROR_NO_NAME_FOUND);
			} else {
				cmd.setCommandName(USER_COMMAND_ADD);
				cmd.setTask(newDeadline);
			}
		} else {
			Task newTodo = parseTodo(commandArgs);
			if (newTodo.getName().equals(INVALID)) {
				logger.log(Level.INFO, LOG_END);
				return initInvalidCommand(ERROR_NO_NAME_FOUND);
			} else {
				cmd.setCommandName(USER_COMMAND_ADD);
				cmd.setTask(newTodo);
			}
		}
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	/**
	 * Parses user input, creates an EditSpecification, and initializes an
	 * Command object with editSpecificatoin field initialized accordingly.
	 * 
	 * @param commandArgs
	 *            details for the edit command
	 * @return edit command if user inputs is valid, invalid command otherwise.
	 */
	private Command initEditCommand(String commandArgs) {
		logger.log(Level.INFO, LOG_PROCESS);
		Edit cmd = new Edit();
		EditSpecification edit = new EditSpecification();
		String[] editArgs = commandArgs.trim().split(" ", 3);

		String taskNumber;
		String fieldOrClear;
		String argumentsForEdit;
		try {
			taskNumber = editArgs[0].trim();
			fieldOrClear = editArgs[1].trim();
			argumentsForEdit = editArgs[2].trim();
		} catch (IndexOutOfBoundsException e) {
			logger.log(Level.WARNING, LOG_ERROR, e);
			return initInvalidCommand(ERROR_INVALID_NUM_ARGS);
		}

		try {
			edit.setTaskNumber(Integer.parseInt(taskNumber));
		} catch (NumberFormatException e) {
			logger.log(Level.WARNING, LOG_ERROR, e);
			return initInvalidCommand(ERROR_INTEGER_NOT_FOUND);
		}

		if (argumentsForEdit.equals(EMPTY_STRING)) {
			return initInvalidCommand(ERROR_INVALID_NUM_ARGS);
		}

		switch (fieldOrClear) {
		case KW_CLEAR:
			edit.setFieldToClear(argumentsForEdit);
			break;
		default:
			edit.setFieldToEdit(editArgs[1]);
			edit.setTheEdit(argumentsForEdit);
		}

		cmd.setEditSpecification(edit);
		cmd.setCommandName(USER_COMMAND_EDIT);
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	/**
	 * @param commandArgs
	 *            details regarding the task the user wants to delete.
	 * @return a Delete command if the user provides an integer as a task
	 *         number, an invalid command otherwise.
	 */
	private Command initDeleteCommand(String commandArgs) {
		logger.log(Level.INFO, LOG_PROCESS);
		Delete cmd = new Delete();
		cmd.setCommandName(USER_COMMAND_DELETE);
		if (commandArgs.trim().equals(EMPTY_STRING)) {
			return initInvalidCommand(ERROR_NO_TASK_NUM);
		} else {
			try {
				cmd.setTaskNumber(Integer.parseInt(commandArgs.trim()));
			} catch (NumberFormatException e) {
				return initInvalidCommand(ERROR_INTEGER_NOT_FOUND);
			}
		}
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	/**
	 * @param commandArgs
	 *            details regarding the task the user wants to mark as complete.
	 * @return a Complete command if the user provides an integer as a task
	 *         number, an invalid command otherwise.
	 */
	private Command initCompleteCommand(String commandArgs) {
		logger.log(Level.INFO, LOG_PROCESS);
		Completed cmd = new Completed();
		cmd.setCommandName(USER_COMMAND_COMPLETE);
		if (commandArgs.trim().equals(EMPTY_STRING)) {
			return initInvalidCommand(ERROR_NO_TASK_NUM);
		} else {
			try {
				cmd.setTaskNumber(Integer.parseInt(commandArgs.trim()));
			} catch (NumberFormatException e) {
				return initInvalidCommand(ERROR_INTEGER_NOT_FOUND);
			}
		}
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	/**
	 * @param commandArgs
	 *            specification of what the user would like to search for.
	 * @return a Search command if the user provides keywords.
	 */
	private Command initSearchCommand(String commandArgs) {
		logger.log(Level.INFO, LOG_PROCESS);
		Search cmd = new Search();
		if (commandArgs.trim().equals(EMPTY_STRING)) {
			return initInvalidCommand(ERROR_NO_SEARCH_FIELD);
		} else {
			cmd.setCommandName(USER_COMMAND_SEARCH);
			cmd.setSearchSpecification(commandArgs.trim());
		}
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	/**
	 * @param commandArgs
	 *            specification of how the user want to sort tasks.
	 * @return a sort command if the user specifies how he or she want tasks
	 *         sorted , an invalid command otherwise.
	 */
	private Command initSortCommand(String commandArgs) {
		logger.log(Level.INFO, LOG_PROCESS);
		Sort cmd = new Sort();
		if (commandArgs.trim().equals(EMPTY_STRING)) {
			logger.log(Level.INFO, LOG_END);
			return initInvalidCommand(ERROR_NO_SORT_FIELD);
		} else {
			cmd.setCommandName(USER_COMMAND_SORT);
			cmd.setSortField(commandArgs.trim());

		}
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	/**
	 * @param commandArgs
	 *            details regarding where the user wants to save the tasks.
	 * @return a store command initialized accordingly.
	 */
	private Command initStoreCommand(String commandArgs) {
		logger.log(Level.INFO, LOG_PROCESS);
		Store cmd = new Store();
		cmd.setCommandName(USER_COMMAND_STORE);
		cmd.setDirectory(commandArgs.trim());
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	// The folllowing init commands initializes the commandNamea of the commands
	// accordingly
	private Command initRetrieveCommand(String commandName) {
		logger.log(Level.INFO, LOG_PROCESS);
		Retrieve cmd = new Retrieve();
		cmd.setCommandName(commandName.trim());
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	private Command initCommand(String commandName) {
		logger.log(Level.INFO, LOG_PROCESS);
		InitCommand cmd = new InitCommand();
		cmd.setCommandName(commandName.trim());
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	private Command initViewIncompleteCommand(String commandName) {
		logger.log(Level.INFO, LOG_PROCESS);
		ViewIncomplete cmd = new ViewIncomplete();
		cmd.setCommandName(commandName.trim());
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	private Command initUndoCommand(String commandName) {
		logger.log(Level.INFO, LOG_PROCESS);
		Undo cmd = new Undo();
		cmd.setCommandName(commandName.trim());
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	private Command initViewCompletedCommand(String commandName) {
		logger.log(Level.INFO, LOG_PROCESS);
		ViewCompleted cmd = new ViewCompleted();
		cmd.setCommandName(commandName.trim());
		logger.log(Level.INFO, LOG_END);
		return cmd;
	}

	private Command initInvalidCommand(String errorMessage) {
		logger.log(Level.INFO, LOG_PROCESS);
		assert (!errorMessage.equals(EMPTY_STRING));
		InitCommand c = new InitCommand();
		c.setCommandName(INVALID);
		c.setErrorMessage(errorMessage);
		logger.log(Level.INFO, LOG_END);
		return c;
	}

	// Helper methods
	/**
	 * @param args
	 *            details regarding the event
	 * @return task object initialized as an event if the event was able to me
	 *         parsed. otherwise, it will return a task object with name
	 *         initialized to invalid.
	 */
	public Task parseEvent(String args) {
		logger.log(Level.INFO, LOG_PROCESS);
		Task newEvent = new Task();
		newEvent.setTaskType(TASK_TYPE_EVENT);
		boolean hasStart = false;
		boolean hasEnd = false;
		if (args.contains(KW_START)) {
			DateTime start = DateTimeParser.parse(getDateTime(args, KW_START));
			if (start != null) {
				newEvent.setStart(start);
				newEvent.setName(getTaskName(args, KW_START));
				hasStart = true;
			} else {
				logger.log(Level.INFO, LOG_END);
				return new Task(INVALID);
			}
		}
		if (args.contains(KW_END)) {
			DateTime end = DateTimeParser.parse(getDateTime(args, KW_END));
			if (end != null) {
				if (!hasStart) {
					newEvent.setName(getTaskName(args, KW_END));
				}
				newEvent.setEnd(end);
				hasEnd = true;
			} else {
				logger.log(Level.INFO, LOG_END);
				return new Task(INVALID);
			}
		}
		if (!hasStart) {
			DateTime start = newEvent.getEnd().minusHours(1);
			newEvent.setStart(start);
		}
		if (!hasEnd) {
			DateTime end = newEvent.getStart().plusHours(1);
			newEvent.setEnd(end);
		}
		logger.log(Level.INFO, LOG_END);
		return newEvent;
	}

	/**
	 * @param args
	 *            details regarding the deadline
	 * @return task object initialized as an deadline if the deadline was able
	 *         to me parsed. otherwise, it will return a task object with name
	 *         initialized to invalid.
	 */
	public Task parseDeadline(String args) {
		logger.log(Level.INFO, LOG_PROCESS);
		Task newDeadline = new Task();
		newDeadline.setTaskType(TASK_TYPE_DEADLINE);
		if (hasDateTime(args)) {
			DateTime completeBy = DateTimeParser.parse(getDateTime(args, getKeyword(args)));
			if (completeBy != null) {
				newDeadline.setCompleteBy(completeBy);
				newDeadline.setName(getTaskName(args, getKeyword(args)));
			} else {
				logger.log(Level.INFO, LOG_END);
				return new Task(INVALID);
			}
		} else {
			logger.log(Level.INFO, LOG_END);
			return parseTodo(args);
		}
		logger.log(Level.INFO, LOG_END);
		return newDeadline;
	}

	/**
	 * @param args
	 *            details regarding the todo task
	 * @return task object initialized as a todo a name or description is
	 *         provided. otherwise, it will return a task object with name
	 *         initialized to invalid.
	 */
	public Task parseTodo(String args) {
		logger.log(Level.INFO, LOG_PROCESS);
		Task newTodo = new Task();
		newTodo.setTaskType(TASK_TYPE_TODO);
		if ((args.trim()).equals(EMPTY_STRING)) {
			logger.log(Level.INFO, LOG_END);
			return new Task(INVALID);
		} else {
			newTodo.setName(args);
		}
		logger.log(Level.INFO, LOG_END);
		return newTodo;
	}

	/**
	 * Helper method for parsing deadline. Determine which keyword is in the
	 * deadline specification.
	 * 
	 * @param args string that entails the deadline details
	 * @return the appropriate keyword -- "on" or "by"
	 */
	public String getKeyword(String args) {
		logger.log(Level.INFO, LOG_PROCESS);
		if (args.contains(KW_ON)) {
			logger.log(Level.INFO, LOG_END);
			return KW_ON;
		} else {
			logger.log(Level.INFO, LOG_END);
			return KW_BY;
		}
	}

	/**
	 * Helper method to get task name. Task name appears before first keyword.
	 */
	private String getTaskName(String args, String keyword) {
		logger.log(Level.INFO, LOG_PROCESS);
		Pattern taskNamePattern = Pattern.compile(PATTERN_TASK_NAME + keyword);
		Matcher m = taskNamePattern.matcher(args.trim());
		if (m.find()) {
			logger.log(Level.INFO, LOG_END);
			return m.group(1).trim();
		} else {
			logger.log(Level.INFO, LOG_END);
			return "";
		}
	}

	/**
	 * Given a string, determine if it has a datetime.
	 */
	public boolean hasDateTime(String args) {
		logger.log(Level.INFO, LOG_PROCESS);
		Pattern dateTimePattern = Pattern.compile(PATTERN_DATE);
		Matcher m = dateTimePattern.matcher(args);
		if (m.find()) {
			logger.log(Level.INFO, LOG_END);
			return true;
		} else {
			logger.log(Level.INFO, LOG_END);
			return false;
		}
	}

	/**
	 * Helper method to get the DateTime from user input. Date time are wrapped
	 * in quotes.
	 */
	public String getDateTime(String args) {
		logger.log(Level.INFO, LOG_PROCESS);
		Pattern dateTimePattern = Pattern.compile(PATTERN_DATE);
		Matcher m = dateTimePattern.matcher(args);
		if (m.find()) {
			logger.log(Level.INFO, LOG_END);
			return m.group(1);
		} else {
			logger.log(Level.INFO, LOG_END);
			return "";
		}
	}

	/**
	 * Helper method to get the DateTime from user input. Date time are wrapped
	 * in quotes.
	 */
	public String getDateTime(String args, String keyword) {
		logger.log(Level.INFO, LOG_PROCESS);
		Pattern dateTimePattern = Pattern.compile(keyword + " " + PATTERN_DATE);
		Matcher m = dateTimePattern.matcher(args);
		if (m.find()) {
			logger.log(Level.INFO, LOG_END);
			return m.group(1);
		} else {
			logger.log(Level.INFO, LOG_END);
			return "";
		}
	}

	private boolean isEvent(String args) {
		logger.log(Level.INFO, LOG_PROCESS);
		String start = " " + KW_START + " ";
		String end = " " + KW_END + " ";
		if (args.contains(start) || args.contains(end)) {
			logger.log(Level.INFO, LOG_END);
			return true;
		} else {
			logger.log(Level.INFO, LOG_END);
			return false;
		}
	}

	private boolean isDeadline(String addCmdArgs) {
		logger.log(Level.INFO, LOG_PROCESS);
		if (hasDateTime(addCmdArgs)) {
			if (addCmdArgs.contains(KW_ON) || addCmdArgs.contains(KW_BY)) {
				logger.log(Level.INFO, LOG_END);
				return true;
			} else {
				logger.log(Level.INFO, LOG_END);
				return false;
			}
		} else {
			logger.log(Level.INFO, LOG_END);
			return false;
		}
	}
}
```
###### parser\DateTimeParser.java
``` java

/**
 * Parses string into DateTime objects
 *
 */
public class DateTimeParser {
	// 3 PARAM DATES
	private static final String DATE_FMT_3_1 = "dd MMMM yyyy"; // 14 November
																// 2015
	private static final String DATE_FMT_3_2 = "dd MMM yyyy"; // 14 Nov 2015

	// 2 PARAM DATES NO YEARS
	private static final String DATE_FMT_2_1 = "dd MMM"; // 14 Nov no year
	private static final String DATE_FMT_2_2 = "dd MMMM"; // 14 November no year

	// 1 PARAM DATES
	private static final String DATE_FMT_1_1 = "ddMMyyyy"; // 14112015
	private static final String DATE_FMT_1_2 = "dd/MM/yy"; // 14/11/15
	private static final String DATE_FMT_1_2_5 = "dd/MM/yyyy"; // 14/11/2015
	private static final String DATE_FMT_1_3 = "ddMMyy"; // 141115

	// 1 PARAM DATES NO YEARS
	private static final String DATE_FMT_1_4 = "dd/MM"; // 14/11 no year
	private static final String DATE_FMT_1_5 = "ddMM"; // 1411 no year
	private static final String DATE_FMT_1_6 = "ddMMM"; // 12Nov
	private static final String DATE_FMT_1_7 = "ddMMMM"; // 12November

	// 1 PARAM TIMES
	private static final String TIME_FMT_1_1 = "hh:mma"; // 5:00am
	private static final String TIME_FMT_1_2 = "hhmma"; // 500am
	private static final String TIME_FMT_1_3 = "hha"; // 5am
	private static final String TIME_FMT_1_4 = "hh.mma"; // 5.00am
	private static final String TIME_FMT_1_5 = "kmm"; // 2100
	private static final String TIME_FMT_1_6 = "k:mm"; // 21:00
	private static final String TIME_FMT_1_7 = "k"; // 21
	private static final String TIME_FMT_1_8 = "k.mm"; // 21.55

	// 2 PARAM TIMES
	private static final String TIME_FMT_2_1 = "hh:mm a"; // 5:00 am
	private static final String TIME_FMT_2_2 = "hh.mm a"; // 5.00 am
	private static final String TIME_FMT_2_3 = "hhmm a"; // 500 am
	private static final String TIME_FMT_2_4 = "hh a"; // 5 am

	private static final String[] DATE_FMTS_1_PART = { DATE_FMT_1_1, DATE_FMT_1_2, DATE_FMT_1_2_5, DATE_FMT_1_3 };
	private static final String[] DATE_FMTS_1_PART_NO_YEAR = { DATE_FMT_1_4, DATE_FMT_1_5, DATE_FMT_1_6, DATE_FMT_1_7 };
	private static final String[] DATE_FMTS_2_PART_NO_YEAR = { DATE_FMT_2_1, DATE_FMT_2_2 };
	private static final String[] DATE_FMTS_3_PARTS = { DATE_FMT_3_1, DATE_FMT_3_2 };

	private static final String[] TIME_FMTS_1_PART = { TIME_FMT_1_1, TIME_FMT_1_2, TIME_FMT_1_3, TIME_FMT_1_4,
			TIME_FMT_1_5, TIME_FMT_1_6, TIME_FMT_1_7, TIME_FMT_1_8 };
	private static final String[] TIME_FMTS_2_PARTS = { TIME_FMT_2_1, TIME_FMT_2_2, TIME_FMT_2_3, TIME_FMT_2_4 };

	private static final String PATTERN_ORDINAL = "(\\d(rd|st|nd|th)+)";
	private static final String PATTERN_CARDINAL = "([0-9]+)";
	private static final String BAD_TIME_FMT1 = "(\\s\\d{3}\\s*(am|pm))";
	private static final String BAD_TIME_FMT2 = "(\\s\\d{3}\\b)";

	private static final String[] EMPTY_SET = {};
	private static final String EMPTY_STRING = "";

	private static DateTime current = new DateTime();

	/**
	 * Parses user input into DateTime objects according to the number of
	 * parameters in the input, whether or not a year was specified, or whether
	 * or not a time was specified.
	 * 
	 * @return DateTime object if input can be parsed, null otherwise.
	 */
	public static DateTime parse(String input) {
		DateTime dateTime;
		String reformattedInput = reformatDate(replaceBadTimeInput(input));
		switch (getNumDateTimeParam(reformatDate(replaceBadTimeInput(input)))) {
		case 1:
			dateTime = parseOneParamDateTime(reformattedInput);
			break;
		case 2:
			dateTime = parseTwoParamDateTime(reformattedInput);
			break;
		case 3:
			dateTime = parseThreeParamDateTime(reformattedInput);
			break;
		case 4:
			dateTime = parseFourParamDateTime(reformattedInput);
			break;
		case 5:
			dateTime = parseFiveParamDateTime(reformattedInput);
			break;
		default:
			dateTime = null;
		}
		return dateTime;
	}

	private static DateTime parseDateTime(String input, String[] dates, String[] times, boolean hasYear) {
		DateTime dateTime = null;
		if (times.length > 0 && hasYear) {
			for (int i = 0; i < dates.length; i++) {
				for (int j = 0; j < times.length; j++) {
					if (dateTime == null) {
						dateTime = parseDateTimeWithYear(input, dates[i], times[j]);
					} else {
						break;
					}
				}
			}
		} else if (times.length > 0 && !hasYear) {
			for (int i = 0; i < dates.length; i++) {
				for (int j = 0; j < times.length; j++) {
					if (dateTime == null) {
						dateTime = parseDateTimeNoYear(input, dates[i], times[j]);
					} else {
						break;
					}
				}
			}
		} else if (times.length == 0 && hasYear) {
			for (int i = 0; i < dates.length; i++) {
				if (dateTime == null) {
					dateTime = parseDateWithNoTime(input, dates[i]);
				} else {
					break;
				}
			}
		} else if (times.length == 0 && !hasYear) {
			for (int i = 0; i < dates.length; i++) {
				if (dateTime == null) {
					dateTime = parseDateNoTimeNoYear(input, dates[i]);
				} else {
					break;
				}

			}
		}
		return dateTime;
	}

	private static DateTime parseFiveParamDateTime(String input) {
		return parseDateTime(input, DATE_FMTS_3_PARTS, TIME_FMTS_2_PARTS, false);
	}

	private static DateTime parseFourParamDateTime(String input) {
		DateTime dateTime = parseDateTime(input, DATE_FMTS_3_PARTS, TIME_FMTS_1_PART, true);
		if (dateTime == null) {
			dateTime = parseDateTime(input, DATE_FMTS_2_PART_NO_YEAR, TIME_FMTS_2_PARTS, false);
		}
		return dateTime;
	}

	private static DateTime parseThreeParamDateTime(String input) {
		DateTime dateTime = parseDateTime(input, DATE_FMTS_3_PARTS, EMPTY_SET, true);
		if (dateTime == null) {
			dateTime = parseDateTime(input, DATE_FMTS_2_PART_NO_YEAR, TIME_FMTS_1_PART, false);
		}
		if (dateTime == null) {
			dateTime = parseDateTime(input, DATE_FMTS_1_PART, TIME_FMTS_2_PARTS, true);
		}
		if (dateTime == null) {
			dateTime = parseDateTime(input, DATE_FMTS_1_PART_NO_YEAR, TIME_FMTS_2_PARTS, false);
		}
		return dateTime;
	}

	private static DateTime parseTwoParamDateTime(String input) {
		DateTime dateTime = parseDateTime(input, DATE_FMTS_2_PART_NO_YEAR, EMPTY_SET, false);
		if (dateTime == null) {
			dateTime = parseDateTime(input, DATE_FMTS_1_PART, TIME_FMTS_1_PART, true);
		}
		if (dateTime == null) {
			dateTime = parseDateTime(input, DATE_FMTS_1_PART_NO_YEAR, TIME_FMTS_1_PART, false);
		}
		return dateTime;
	}

	private static DateTime parseOneParamDateTime(String input) {
		DateTime dateTime = parseDateTime(input, DATE_FMTS_1_PART, EMPTY_SET, true);
		if (dateTime == null) {
			dateTime = parseDateTime(input, DATE_FMTS_1_PART_NO_YEAR, EMPTY_SET, false);
		}
		return dateTime;
	}

	private static DateTime parseDateTimeWithYear(String input, String dateFmt, String timeFmt) {
		DateTime dateTime;
		try {
			DateTimeFormatter formatter = DateTimeFormat.forPattern(dateFmt + " " + timeFmt);
			dateTime = formatter.parseDateTime(input.trim());
		} catch (IllegalArgumentException e) {
			dateTime = null;
		}
		return dateTime;
	}

	private static DateTime parseDateWithNoTime(String input, String dateFmt) {
		DateTime dateTime;
		try {
			DateTimeFormatter formatter = DateTimeFormat.forPattern(dateFmt);
			dateTime = formatter.parseDateTime(input.trim());
		} catch (IllegalArgumentException e) {
			dateTime = null;
		}
		return dateTime;
	}

	private static DateTime parseDateTimeNoYear(String input, String dateFmt, String timeFmt) {
		DateTime dateTime;
		int currentYear = current.getYear();
		try {
			DateTimeFormatter formatter = DateTimeFormat.forPattern(dateFmt + " " + timeFmt);
			dateTime = formatter.parseDateTime(input.trim());
			dateTime = dateTime.plusYears(calculateYearDifference(currentYear, dateTime.getYear()));
		} catch (IllegalArgumentException e) {
			dateTime = null;
		}
		return dateTime;
	}

	private static int calculateYearDifference(int year1, int year2) {
		return year1 - year2;
	}

	private static DateTime parseDateNoTimeNoYear(String input, String dateFmt) {
		DateTime dateTime;
		int currentYear = current.getYear();
		try {
			DateTimeFormatter formatter = DateTimeFormat.forPattern(dateFmt);
			dateTime = formatter.parseDateTime(input.trim());
			dateTime = dateTime.plusYears(calculateYearDifference(currentYear, dateTime.getYear()));
		} catch (IllegalArgumentException e) {
			dateTime = null;
		}
		return dateTime;
	}

	/**
	 * Helper method to determine how many parts did the user input date in.
	 */
	private static int getNumDateTimeParam(String dateTimeString) {
		return dateTimeString.split(" ").length;
	}

	/**
	 * When receive a date has numbers represented in ordinal manner, i.e. 1st,
	 * 2nd... this method replaces that with 1, 2 ... so it can be parsed.
	 * 
	 */
	private static String reformatDate(String date) {
		String ordinal = getOrdinal(date);
		String cardinal = getCardinal(ordinal);
		return date.replaceAll(ordinal, cardinal);
	}

	/**
	 * Helper method to retrieve substring of cardinal time in ordinal format.
	 * 
	 * @return
	 */
	private static String getOrdinal(String input) {
		Pattern dateTimePattern = Pattern.compile(PATTERN_ORDINAL);
		Matcher m = dateTimePattern.matcher(input);
		if (m.find()) {
			return m.group(1);
		} else {
			return "";
		}
	}

	/**
	 * Retrieve the cardinal version of ordinal number
	 */
	private static String getCardinal(String input) {
		Pattern dateTimePattern = Pattern.compile(PATTERN_CARDINAL);
		Matcher m = dateTimePattern.matcher(input);
		if (m.find()) {
			return m.group(1);
		} else {
			return "";
		}
	}

	/**
	 * Identify inputs in bad time format such as 500 am.
	 */
	private static String getBadTimeInput(String input) {
		Pattern dateTimePattern1 = Pattern.compile(BAD_TIME_FMT1);
		Matcher m1 = dateTimePattern1.matcher(input);
		Pattern dateTimePattern2 = Pattern.compile(BAD_TIME_FMT2);
		Matcher m2 = dateTimePattern2.matcher(input);
		if (m1.find()) {
			return m1.group(1);
		} else if (m2.find()) {
			return m2.group(1);
		} else {
			return "";
		}
	}

	/**
	 * Reformats bad time input by appending a 0 in front. That way it can be
	 * parsed by JodaTime's parser.
	 *
	 */
	private static String replaceBadTimeInput(String input) {
		String hmma = getBadTimeInput(input);
		if (hmma.equals(EMPTY_STRING)) {
			return input;
		} else {
			return input.replaceAll(hmma, " 0" + hmma.trim());
		}
	}
}
```
###### storage\Storage.java
``` java
	@Override
	public void addObserver(Observer obj) {
		logger.log(Level.INFO, LOG_PROCESS);
		if(obj == null) {
			throw new NullPointerException(EXCEPTION_MESSAGE_5);
		} else if(!observerList.contains(obj)) {
			observerList.add(obj);
		}
		logger.log(Level.INFO, LOG_END);
	}

	@Override
	public void notifyObservers() {
		logger.log(Level.INFO, LOG_PROCESS);
		for(Observer o : observerList) {
			o.update();
		}
		logger.log(Level.INFO, LOG_END);
	}
}
```
